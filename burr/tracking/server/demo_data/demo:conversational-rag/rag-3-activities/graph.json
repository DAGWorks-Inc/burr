{"type": "application", "entrypoint": "human_converse", "actions": [{"type": "action", "name": "ai_converse", "reads": ["input_texts", "question", "chat_history"], "writes": ["chat_history"], "code": "@action(\n    reads=[\"input_texts\", \"question\", \"chat_history\"],\n    writes=[\"chat_history\"],\n)\ndef ai_converse(state: State) -> Tuple[dict, State]:\n    \"\"\"AI conversing step. This calls out to an API on the Hamilton hub (hub.dagworks.io)\n    to do basic RAG\"\"\"\n    result = conversational_rag_driver.execute(\n        [\"conversational_rag_response\"],\n        inputs={\n            \"input_texts\": state[\"input_texts\"],\n            \"question\": state[\"question\"],\n            \"chat_history\": state[\"chat_history\"],\n        },\n    )\n    new_history = f\"AI: {result['conversational_rag_response']}\"\n    return result, state.append(chat_history=new_history)\n"}, {"type": "action", "name": "human_converse", "reads": [], "writes": ["question", "chat_history"], "code": "@action(\n    reads=[],\n    writes=[\"question\", \"chat_history\"],\n)\ndef human_converse(state: State, user_question: str) -> Tuple[dict, State]:\n    \"\"\"Human converse step -- this simply massages the state to be the right shape\"\"\"\n    state = state.update(question=user_question).append(chat_history=f\"Human: {user_question}\")\n    return {\"question\": user_question}, state\n"}, {"type": "action", "name": "terminal", "reads": ["chat_history"], "writes": [], "code": "class Result(Action):\n    def __init__(self, *fields: str):\n        \"\"\"Represents a result action. This is purely a convenience class to\n        pull data from state and give it out to the result. It does nothing to\n        the state itself.\n\n        :param fields: Fields to pull from the state and put into results\n        \"\"\"\n        super(Result, self).__init__()\n        self._fields = fields\n\n    def run(self, state: State) -> dict:\n        return {key: value for key, value in state.get_all().items() if key in self._fields}\n\n    def update(self, result: dict, state: State) -> State:\n        return state  # does not modify state in any way\n\n    @property\n    def reads(self) -> list[str]:\n        return list(self._fields)\n\n    @property\n    def writes(self) -> list[str]:\n        return []\n"}], "transitions": [{"type": "transition", "from_": "ai_converse", "to": "human_converse", "condition": "default"}, {"type": "transition", "from_": "human_converse", "to": "terminal", "condition": "'exit' in question"}, {"type": "transition", "from_": "human_converse", "to": "ai_converse", "condition": "default"}]}