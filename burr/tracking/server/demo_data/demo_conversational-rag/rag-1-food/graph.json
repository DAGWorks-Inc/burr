{"type": "application", "entrypoint": "human_converse", "actions": [{"type": "action", "name": "ai_converse", "reads": ["question", "chat_history"], "writes": ["chat_history"], "code": "@action(\n    reads=[\"question\", \"chat_history\"],\n    writes=[\"chat_history\"],\n)\ndef ai_converse(state: State, vector_store: object) -> Tuple[dict, State]:\n    \"\"\"AI conversing step. Uses Hamilton to execute the conversational pipeline.\"\"\"\n    result = conversational_rag_driver.execute(\n        [\"conversational_rag_response\"],\n        inputs={\n            \"question\": state[\"question\"],\n            \"chat_history\": state[\"chat_history\"],\n        },\n        # we use overrides here because we want to pass in the vector store\n        overrides={\n            \"vector_store\": vector_store,\n        },\n    )\n    new_history = f\"AI: {result['conversational_rag_response']}\"\n    return result, state.append(chat_history=new_history)\n", "inputs": []}, {"type": "action", "name": "human_converse", "reads": [], "writes": ["question", "chat_history"], "code": "@action(\n    reads=[],\n    writes=[\"question\", \"chat_history\"],\n)\ndef human_converse(state: State, user_question: str) -> Tuple[dict, State]:\n    \"\"\"Human converse step -- make sure we get input, and store it as state.\"\"\"\n    state = state.update(question=user_question).append(chat_history=f\"Human: {user_question}\")\n    return {\"question\": user_question}, state\n", "inputs": ["user_question"]}, {"type": "action", "name": "terminal", "reads": ["chat_history"], "writes": [], "code": "class Result(Action):\n    def __init__(self, *fields: str):\n        \"\"\"Represents a result action. This is purely a convenience class to\n        pull data from state and give it out to the result. It does nothing to\n        the state itself.\n\n        :param fields: Fields to pull from the state and put into results\n        \"\"\"\n        super(Result, self).__init__()\n        self._fields = fields\n\n    def run(self, state: State) -> dict:\n        return {key: value for key, value in state.get_all().items() if key in self._fields}\n\n    def update(self, result: dict, state: State) -> State:\n        return state  # does not modify state in any way\n\n    @property\n    def reads(self) -> list[str]:\n        return list(self._fields)\n\n    @property\n    def writes(self) -> list[str]:\n        return []\n", "inputs": []}], "transitions": [{"type": "transition", "from_": "ai_converse", "to": "human_converse", "condition": "default"}, {"type": "transition", "from_": "human_converse", "to": "terminal", "condition": "'exit' in question"}, {"type": "transition", "from_": "human_converse", "to": "ai_converse", "condition": "default"}]}