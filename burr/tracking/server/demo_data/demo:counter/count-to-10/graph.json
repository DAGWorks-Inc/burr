{"type": "application", "entrypoint": "counter", "actions": [{"type": "action", "name": "counter", "reads": ["counter"], "writes": ["counter"], "code": "@action(reads=[\"counter\"], writes=[\"counter\"])\ndef counter(state: State) -> Tuple[dict, State]:\n    result = {\"counter\": state[\"counter\"] + 1}\n    print(f\"counted to {result['counter']}\")\n    return result, state.update(**result)\n"}, {"type": "action", "name": "result", "reads": ["counter"], "writes": [], "code": "class Result(Action):\n    def __init__(self, *fields: str):\n        \"\"\"Represents a result action. This is purely a convenience class to\n        pull data from state and give it out to the result. It does nothing to\n        the state itself.\n\n        :param fields: Fields to pull from the state and put into results\n        \"\"\"\n        super(Result, self).__init__()\n        self._fields = fields\n\n    def run(self, state: State) -> dict:\n        return {key: value for key, value in state.get_all().items() if key in self._fields}\n\n    def update(self, result: dict, state: State) -> State:\n        return state  # does not modify state in any way\n\n    @property\n    def reads(self) -> list[str]:\n        return list(self._fields)\n\n    @property\n    def writes(self) -> list[str]:\n        return []\n"}], "transitions": [{"type": "transition", "from_": "counter", "to": "counter", "condition": "counter < 10"}, {"type": "transition", "from_": "counter", "to": "result", "condition": "default"}]}